= Sylt Quick Reference

Here you will find most things in Sylt in a concise format.

.Variables
[source, sylt]
----
constant :: 3.14
variable := []
two: int : 2
text: str = "abc"
text = "A short sentence."  // <1>
----

<1> A single `=` is used to set the value of a variable after declaration with
`:=`.

.If-else statements
[source, sylt]
----
if 1 < 0 do
    // ...
else if "hello" == "" do
    // ...
else do
    // ...
end

one :: 1 if true else 2
two :: one + 1 if == 2 else -1 // <1>
----

<1> The left hand side is inserted right after `if`

.Operators
[source, sylt]
----
1 + 1
2 - 2
3 * 3
10 / 2
-4

1 < 2
2 > 1
1 <= 1
1 >= 1
"a" == "a"

[1, 2] <=> [1, 2]  // Assert equal

(1 + 1) * 2

true or false
true and true
not true
----

.Functions
[source, sylt]
----
hello :: fn do
    print("Hello world")
end

add :: fn x: int, y: int -> int do
    ret x + y
end

two_squared :: fn n: int -> int do n * n end(2)  // <1>

// Different ways of calling functions

hello()
print("Hello, world!")
add(1, 2)

hello'
print' "Hello, world!"
add' 1, 2

"Hello, world!" -> print()
1 -> add' 2

[1, 2, 3] -> for_each' fn n: int do
    print(n)
end
----

<1> This creates a function which returns implicitly and calls it immediately.

.Types
[source, sylt]
----
// Basic types
integer: int = 100
decimal: float = 1.5
string: str = "hello"
list: [int] = [1, 2, 3]
tuple: (str, float) = ("cookies", 1.5)
dict: {str: int} = {"a": 1, "b": 2}
set: {int} = {1, 2, 3}
function: fn -> void = fn do end
nothing: void = nil

// Other types

forced_int: !int = "str"
union: int | str = 1
union = "now a string"
maybe_int: int? = nil
maybe_int = 1

// Special cases

empty_dict := {:}
empty_set := {}
empty_tuple: () = ()
one_element_tuple: (int,) = (1,)
----

.Imports
[source, sylt]
----
use file          // file.thing
use folder/file   // file.thing
use folder/       // folder.thing <1>
use file as name  // name.thing
use /res/         // res.thing    <2>
----

<1> Same as `use folder/exports.sy as folder`.
<2> Leading `/` signifies the project root.
