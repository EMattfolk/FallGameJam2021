use love as l
from love use love

Color :: blob {
    red: float,
    green: float,
    blue: float,
    alpha: float,
}

// NOTE(ed): Might be nice to convert HSL to RGB?
rgb :: fn r, g, b -> Color
    Color { red: r, green: g, blue: b, alpha: 1. }
end
rgba :: fn r, g, b, a -> Color
    Color { red: r, green: g, blue: b, alpha: a }
end
stableRandomColor :: fn i: float -> Color
    r :: rem' 0.3 + i * 3.33, 1.
    g :: rem' 0.2 + i * 7.77, 1.
    b :: rem' 0.7 + i * 5.55, 1.
    rgb' r, g, b
end

setColor :: fn color do
    love.graphics.setColor' (color.red, color.green, color.blue, color.alpha)
end

drawLine :: fn color, a, b do
    setColor' color
    love.graphics.line' a[0], a[1], b[0], b[1]
end

drawCircle :: fn color, p, r do
    setColor' color
    love.graphics.circle' "fill", p[0], p[1], r
end

drawCircleOutline :: fn color, p, r do
    setColor' color
    love.graphics.circle' "line", p[0], p[1], r
end

drawRect :: fn color, p, dim do
    setColor' color
    love.graphics.rectangle' "fill", p[0], p[1], dim[0], dim[1]
end

drawRectCentered :: fn color, p, dim do
    drawRect' color, p - dim / (2., 2.), dim
end

drawRectOutline :: fn color, p, dim do
    setColor' color
    love.graphics.rectangle' "line", p[0], p[1], dim[0], dim[1]
end

drawRectCenteredOutline :: fn color, p, dim do
    drawRectOutline' color, p - dim / (2., 2.), dim
end

Alignment :: enum
    Center,
    Left,
    Right
end

alignmentToStr :: fn a ->
    case a do
        Center ret "center"
        Left ret "left"
        Right ret "right"
        else do <!> end
    end
    ret ""
end

Font :: blob {
    // Not really happy with this...
    drawText: fn Color, str, (float, float) -> void,
    drawTextT: fn Color, str, (float, float), float, float -> void,
    drawTextF: fn Color, str, (float, float), Alignment, float -> void,
    drawTextFT: fn Color, str, (float, float), Alignment, float, float, float -> void,
}

drawText :: fn color, text, pos, r, s do
    setColor' color
    love.graphics.print' text, pos[0], pos[1], r, s, s
end

drawTextFT :: fn color, text, pos, alignment, maxWidth, r, s do
    setColor' color
    love.graphics.printf' text, pos[0], pos[1], maxWidth, alignmentToStr(alignment), r, s, s
end

// Returns a font that can be used
aFont :: fn -> Font
    f :: love.graphics.getFont()
    Font {
        drawText: fn color, text, pos do
            love.graphics.setFont' f
            drawText' color, text, pos, 0., 1.
        end,
        drawTextT: fn color, text, pos, r, s do
            love.graphics.setFont' f
            drawText' color, text, pos, r, s
        end,
        drawTextF: fn color, text, pos: (float, float), alignemnt, maxWidth do
            love.graphics.setFont' f
            drawTextFT' color, text, pos, alignemnt, maxWidth, 0., 1.
        end,
        drawTextFT: fn color, text, pos, alignemnt, maxWidth, r, s do
            love.graphics.setFont' f
            drawTextFT' color, text, pos, alignemnt, maxWidth, r, s
        end,
    }
end

Image :: blob {
    img: *,
    getWidth: fn -> float,
    getHeight: fn -> float,
    draw: fn (float, float), float, (float, float) -> void,
    drawTinted: fn Color, (float, float), float, (float, float) -> void,
    drawCenterd: fn (float, float), float, (float, float) -> void,
    drawTintedCentered: fn Color, (float, float), float, (float, float) -> void,
}

drawImage :: fn tint, img: l.ImageData, pos, rot, scale do
    setColor' tint
    x :: love.graphics.draw
    x' img, pos[0], pos[1], rot, scale[0], scale[1], 0., 0., 0.
end

drawImageCentered :: fn tint, img: l.ImageData, pos, rot, scale do
    w :: img.getWidth' img
    h :: img.getHeight' img
    setColor' tint

    // Work around for bug in typesystem, we don't copy
    // functions if they're fields.
    x :: love.graphics.draw
    x' img, pos[0], pos[1], rot, scale[0], scale[1], w / 2., h / 2., 0.
end

newImage :: fn filepath: str -> Image
    img : l.ImageData : love.graphics.newImage' filepath
    Image {
        img: img,
        getWidth: fn -> img.getWidth' img end,
        getHeight: fn -> img.getHeight' img end,
        draw: fn pos, rot, scale do
            drawImage' rgb(1., 1., 1.), img, pos, rot, scale
        end,
        drawTinted: fn tint, pos, rot, scale do
            drawImage' tint, img, pos, rot, scale
        end,
        drawCenterd: fn pos, rot, scale do
            drawImageCentered' rgb(1., 1., 1.), img, pos, rot, scale
        end,
        drawTintedCentered: fn tint, pos, rot, scale do
            drawImageCentered' tint, img, pos, rot, scale
        end,
    }
end

Particles :: blob {
    particles: l.ParticleSystem,
    setLifetime: fn float, float -> void,
    setEmissionRate: fn int -> void,
    setLinearAcceleration: fn (float, float), (float, float) -> void,

    update: fn float -> void,
    draw: fn Color -> void,
    drawAt: fn Color, (float, float) -> void,
}

drawParticlesAt :: fn tint, particles: Particles, pos do
end

updateParticles :: fn particles: Particles, delta do
    particles.update(delta)
end

newParticles :: fn image: Image ->
    particles :: love.graphics.newParticleSystem' image.img, 1000
    Particles {
        particles: particles,
        setLifetime: fn lo, hi do
            particles.setParticleLifetime' particles, lo, hi
        end,
        setEmissionRate: fn rate do
            particles.setEmissionRate' particles, rate
        end,
        setLinearAcceleration: fn lo, hi do
            particles.setLinearAcceleration' particles, lo[0], lo[1], hi[0], hi[1]
        end,

        update: fn delta do
            particles.update' particles, delta
        end,
        draw: fn tint do
            setColor' tint
            x :: love.graphics.draw
            x' particles, 0., 0., 0., 1., 1., 0., 0., 0.
        end,
        drawAt: fn tint, pos do
            setColor' tint
            x :: love.graphics.draw
            x' particles, pos[0], pos[1], 0., 1., 1., 0., 0., 0.
        end,
    }
end
