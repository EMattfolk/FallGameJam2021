from /love use (love, Shader)
use /love as l
use /res/
use /input
use /gfx

use controller as ctrl
use graph
use menu
use guy

from /main use varargs

clone :: fn list ->
    list -> map' fn x -> x end
end

// Shuffle, but badly
shuffle :: fn list: [*] do
    if len(list) == 0 ret

    le := len(list)
    list -> for_each' fn _ do
        a :: love.math.random(0, le-1)
        b :: love.math.random(0, le-1)
        temp :: list[a]
        list[a] = list[b]
        list[b] = temp
    end
end

// Colors
BACKGROUND_COLOR :: gfx.rgb' 50. / 255., 50. / 255., 50. / 255.
MENU_COLOR :: gfx.rgb' 1., 1., 1.
HEADER_COLOR :: gfx.rgb' 209. / 255., 59. / 255., 57. / 255.
SELECTED_COLOR :: gfx.rgb' 229. / 255., 126. / 255., 124. / 255.
WHITE :: gfx.rgb' 1., 1., 1.


guy_to_move :: fn state ->
    ret state.guys_to_move[guy.faction_to_int(state.player_turn)] -> last'
end

move_active_guy :: fn state, dir do
    g :: state -> guy_to_move'
    old :: g.node
    new :: graph.facingNeighbour' old, dir, state.graph
    g.node = new

    diff :: state.graph.nodes[old].position - state.graph.nodes[new].position
    f :: 25.0
    state.graph.nodes[new].velocity -= diff * (f, f)

    kill := false
    ff :: guy.faction_to_int(g.faction)

    state.factions -> for_each' fn other_fn do
        if g.faction == other_fn ret

        // friendly faction
        ef := guy.faction_to_int(other_fn)

        kill = false
        state.guys[ef] = state.guys[ef] -> filter' fn other_guy -> do
            if other_guy.node == g.node and not kill do
                kill = true
                state.guys_to_move[ef] = state.guys_to_move[ef] -> filter' fn other_other_guy -> do
                    other_other_guy != other_guy
                end
                ret false
            else do
                ret true
            end
        end

        if kill do
            print' g
            state.guys[ff] = state.guys[ff] -> filter' fn friendly_guy -> do
                friendly_guy != g
            end
        end
    end

    node :: state.graph.nodes[g.node]

    f :: g.faction

    if not kill do
        node.tile = (fn ->
            case node.tile do
                Captured _ ret graph.Tile.Captured f
                Empty ret graph.Tile.Captured f
                Factory _ ret graph.Tile.Factory f
                EmptyFactory ret graph.Tile.Factory f
                Base f ret graph.Tile.Base f
                else do
                    print' "Remember to add new tile!"
                    <!>
                end
            end
            ret graph.Tile.Empty
        end)()
    end

    if not kill and state.moves_left > 0 do
        case state.inputState do
            MoveGuyDirection _ do
                state.inputState = InputState.MoveGuy
            end
            else do <!> end
        end

        state.moves_left = state.moves_left - 1
    else do
        next_turn' state
    end
end


next_turn :: fn state do
    faction_i :: guy.faction_to_int' state.player_turn
    state.guys_to_move[faction_i] -> pop'

    num_factions :: len' state.factions
    next_faction_i :: faction_i + 1
    i :: rem' next_faction_i, num_factions

    state.player_turn = state.factions[i]
    state.moves_left = 1
    state.inputState = InputState.MoveGuy

    fi :: guy.faction_to_int' state.player_turn

    to_move :: state.guys_to_move[fi]

    guys :: state.guys[fi]

    end_of_turn :: len(to_move) == 0 and fi == 0
    if end_of_turn do
        state.turn += 1
    end

    if end_of_turn and rem(state.turn, 4) == 0 do
        state.score += graph.scoreGraph' state.graph
    end

    if len(to_move) == 0 do
        i := 0
        loop i < len(state.graph.nodes) do
            spawn :: fn faction do
                if faction == state.player_turn do
                    guys -> push' guy.new_guy(faction, i)
                end
            end

            case state.graph.nodes[i].tile do
                Base faction do
                    spawn' faction
                end
                Factory faction do
                    spawn' faction
                end
                else do end
            end
            i = i + 1
        end

        state.guys_to_move[fi] = guys -> clone'
        shuffle' state.guys_to_move[fi]
    end
end


makeFullscreen :: fn do
    w := l.WindowFlags {
        fullscreen: true,
        fullscreentype: "desktop",
        vsync: 0,
        msaa: 2,
        resizable: false,
        borderless: false,
        centered: false,
        display: 0,
        minwidth: 100,
        minheight: 100,
    }
    love.window.setMode' 0, 0, w
end

States :: enum
    MainMenu menu.Menu,
    Game GameState,
end

InputState :: enum
    MoveGuy,
    MoveGuyDirection (float, float), // direction xy
end

GameState :: blob {
    graph: graph.Graph,
    guys: {int: [guy.Guy]},
    guys_to_move: {int: [guy.Guy]},
    score: (int, int, int, int),
    turn: int,
    factions: [guy.Faction],
    player_turn: guy.Faction,
    moves_left: int,
    inputState: InputState,
}

send_shader_graph_positions :: fn shader: Shader, points do
    // !!!!!!!! DON'T DO THIS AT HOME !!!!!!!
    do
        v : [int] : [
            unsafe_force(shader),
            unsafe_force("vertex_positions"),
        ]
        points -> for_each' fn x do
            v -> push' unsafe_force' (x[0], x[1])
        end
        varargs(shader.send)(v)
    end

    do
        v : [int] : [
            unsafe_force(shader),
            unsafe_force("vertex_colors"),
        ]
        points -> for_each' fn x do
            v -> push' unsafe_force' x[2]
        end
        varargs(shader.send)(v)
    end

    do
        v :: [
            unsafe_force(shader),
            unsafe_force("num_vertex_positions"),
            len(points),
        ]
        varargs(shader.send)(v)
    end
end

init :: fn do
    makeFullscreen'

    ctrl.initControllers' 2

    res.loadResources()

    defaultFont :: gfx.createFont(love.graphics.getFont())
    mainMenuFont :: gfx.createFont(res.font["menu"])

    scene := States.MainMenu menu.createMenu([])
    scene = States.MainMenu menu.createMenu([
        ("Start", fn do
            blue_guys :: [
                guy.new_guy(guy.Faction.Blueberry, 7),
            ]
            cloud_guys :: [
                guy.new_guy(guy.Faction.Cloudberry, 13),
            ]
            state :: GameState {
                graph: graph.createGraph(),
                guys: {
                    guy.faction_to_int(guy.Faction.Blueberry): blue_guys,
                    guy.faction_to_int(guy.Faction.Cloudberry): cloud_guys,
                },
                guys_to_move: {
                    guy.faction_to_int(guy.Faction.Blueberry): blue_guys,
                    guy.faction_to_int(guy.Faction.Cloudberry): cloud_guys,
                },
                factions: [guy.Faction.Blueberry, guy.Faction.Cloudberry],
                player_turn: guy.Faction.Blueberry,
                score: (0, 0, 0, 0),
                turn: 1,
                moves_left: 1,
                inputState: InputState.MoveGuy,
            }
            state.factions -> for_each' fn faction do
                fi :: guy.faction_to_int' faction

                state.guys_to_move[fi] = state.guys[fi] -> clone'
            end

            scene = States.Game state
        end),
        ("Exit", fn do
            love.event.quit' 0
        end)
    ])

    update :: fn delta do
        case scene do
            MainMenu _ do
            end
            Game state do
                graph.updateGraph' state.graph, delta
                graph.scoreGraph' state.graph

                // Update animation timers
                state.factions -> for_each' fn f do
                    guys :: state.guys_to_move[guy.faction_to_int(f)]
                    guys -> for_each' fn g do
                        guy.updateGuy' g, delta
                    end
                end

                // Inputs
                case state.inputState do
                    MoveGuy do
                        may_dir := inputDirection'
                        case may_dir do
                            Just dir do
                                state.inputState = InputState.MoveGuyDirection dir
                            end
                            else do end
                        end
                    end

                    MoveGuyDirection _ do
                        may_dir := inputDirection'
                        case may_dir do
                            Just dir do
                                state.inputState = InputState.MoveGuyDirection dir
                            end
                            else do end
                        end
                    end

                    else do end
                end

            end
            else do <!> end
        end

        ctrl.postTick'
    end

    voronoiShader :: love.graphics.newShader("res/voronoi.glsl")

    draw :: fn do
        drawVoronoiBackground :: fn vertices: [(*, *, *)] do
            love.graphics.setShader' voronoiShader
            send_shader_graph_positions' voronoiShader, vertices
            gfx.drawRect' WHITE, (0., 0.), (as_float(love.graphics.getWidth'), as_float(love.graphics.getHeight'))
            gfx.clearShader'
        end

        case scene do
            MainMenu menu do
                gfx.drawRect' BACKGROUND_COLOR, (0., 0.), gfx.screenSizef()

                MENU_SIZE :: 1.
                MIDDLE :: gfx.screenSizef() / (2., 2.)

                // Header
                headerBox :: (600.0, 0.0)
                mainMenuFont.drawTextFT(
                    HEADER_COLOR,
                    "Age of Sylt",
                    MIDDLE  - headerBox / (2., 2.) - (0., 250.),
                    gfx.Alignment.Center,
                    600.0,
                    0.0,
                    MENU_SIZE
                )

                // Choices
                choiceBox :: (300.0, 0.0)
                offset := (0.0, -80.)
                i := 0
                menu.choices -> for_each' fn choice do
                    color := MENU_COLOR
                    if i == menu.position do
                        color = SELECTED_COLOR
                    end

                    mainMenuFont.drawTextFT(
                        color,
                        choice[0],
                        MIDDLE - choiceBox / (2., 2.) + offset,
                        gfx.Alignment.Center,
                        choiceBox[0],
                        0.0,
                        MENU_SIZE
                    )
                    offset += (0.0, 80.0)
                    i += 1
                end

                // Crests
                B_OFFEST :: (200., 0.)
                C_OFFSET :: (-200., 0.)
                G_OFFSET :: (100., 200.)
                S_OFFSET :: (-100., 200.)
                SCALE :: (2.0, 2.0)
                guy.crest_image(guy.Faction.Blueberry).drawCentered' MIDDLE + B_OFFEST, 0.0, SCALE
                guy.crest_image(guy.Faction.Cloudberry).drawCentered' MIDDLE + C_OFFSET, 0.0, SCALE
                guy.crest_image(guy.Faction.Gooseberry).drawCentered' MIDDLE + G_OFFSET, 0.0, SCALE
                guy.crest_image(guy.Faction.Strawberry).drawCentered' MIDDLE + S_OFFSET, 0.0, SCALE
            end

            Game state do
                offset :: graph.graphCenter' state.graph

                state.graph.nodes -> map(fn node ->
                    (
                        node.position[0] + offset[0],
                        node.position[1] + offset[1],
                        graph.shaderColor(node)
                    )
                end) -> drawVoronoiBackground'

                love.graphics.translate' offset[0], offset[1]
                do
                    graph.drawGraph' state.graph

                    state.factions -> for_each' fn f do
                        guys :: state.guys[guy.faction_to_int(f)]
                        guys -> for_each' fn g do
                            guy.drawGuy' g, state.graph
                        end
                    end

                    case state.inputState do
                        MoveGuyDirection dir do
                            g :: state -> guy_to_move'
                            facing :: graph.facingNeighbour' g.node, dir, state.graph
                            guy.drawGuyDirection' g, facing, state.graph
                        end
                        else do end
                    end
                end
                love.graphics.origin'

                s :: as_str' state.score
                mainMenuFont.drawText' WHITE, s, (100.0, 50.0)
            end

            else do <!> end
        end
    end

    love.keypressed = fn _key, scancode, repeat do
        key := input.strToKeyDict[_key]
        case key do
            Escape do
                print' "Quitting game..."
                love.event.quit' 0
            end else do end
        end

        case scene do
            MainMenu menu do
                case key do
                    Return do
                        menu.select()
                    end
                    Space do
                        menu.select()
                    end
                    Up do
                        menu.up()
                    end
                    Down do
                        menu.down()
                    end
                    else do end
                end
            end
            Game state do
                case state.inputState do
                    MoveGuyDirection dir do
                        case key do
                            Space do
                                move_active_guy' state, dir
                            else do end
                        end
                    end else do end
                end
            end else do <!> end
        end
    end

    love.keyreleased = fn key, scancode do
    end

    love.update = update
    love.draw = draw
end

Maybe :: enum
    Just *,
    Nothing,
end

inputDirection :: fn -> Maybe do // Maybe (float, float)
    res := (0., 0.)
    if input.isKeyDown' input.Key.Up do res += (0., -1.) end
    if input.isKeyDown' input.Key.Down do res += (0., 1.) end
    if input.isKeyDown' input.Key.Left do res += (-1., 0.) end
    if input.isKeyDown' input.Key.Right do res += (1., -0.) end
    if res == (0., 0.,) do
        ret Maybe.Nothing
    end
    ret Maybe.Just (normalize' res)
end
