from /love use (love, Shader)
use /love as l
use /res/
use /input
use /gfx

use graph
use unit

from /main use varargs

newController :: fn -> Controller do
    Controller {
        joystick: (0., 0.),
        finish: false,
        move: false,
    }
end

playerControllers: [Controller] = [ newController(), newController(), ]

Controller :: blob {
    joystick: (float, float),
    finish: bool,
    move: bool,
}

States :: enum
    MainMenu *,
    Game GameState,
end

InputState :: enum
    None,
    MoveUnit int, // unit index
    MoveUnitDirection (int, (float, float)), // unit index, direction [0, 2*pi)
end

GameState :: blob {
    graph: graph.Graph,
    units: [unit.Unit],
    inputState: InputState,
}

send_shader_graph_positions :: fn shader: Shader, points do
    // !!!!!!!! DON'T DO THIS AT HOME !!!!!!!
    do
        v : [int] : [
            unsafe_force(shader),
            unsafe_force("vertex_positions"),
        ]
        points -> for_each' fn x do
            v -> push' unsafe_force' (x[0], x[1])
        end
        varargs(shader.send)(v)
    end

    do
        v : [int] : [
            unsafe_force(shader),
            unsafe_force("vertex_colors"),
        ]
        points -> for_each' fn x do
            v -> push' unsafe_force' x[2]
        end
        varargs(shader.send)(v)
    end

    do
        v :: [
            unsafe_force(shader),
            unsafe_force("num_vertex_positions"),
            len(points),
        ]
        varargs(shader.send)(v)
    end
end

init :: fn do

    res.loadResources()

    aFont :: gfx.aFont()

    scene := States.MainMenu
    time := 0.

    love.gamepadaxis = fn joystick: l.LoveJoystick, axis, size do
        controllerIndex := ((joystick.getID' joystick) - 1) / 2

        if axis == "rightx" do
            controller := playerControllers[controllerIndex]
            controller.joystick = (controller.joystick[0], size)
        end else if axis == "righty" do
            controller := playerControllers[controllerIndex]
            controller.joystick = (size, controller.joystick[1])
        end else if axis == "leftx" do
            controller := playerControllers[controllerIndex+1]
            controller.joystick = (controller.joystick[0], size)
        end else if axis == "lefty" do
            controller := playerControllers[controllerIndex+1]
            controller.joystick = (size, controller.joystick[1])
        end
    end

    love.gamepadpressed = fn joystick: l.LoveJoystick, button do
        controllerIndex := ((joystick.getID' joystick) - 1) / 2
        if button == "rightshoulder" do
            playerControllers[controllerIndex].move = true
        else if button == "a" do
            playerControllers[controllerIndex].finish = true
        else if button == "leftshoulder" do
            playerControllers[controllerIndex+1].move = true
        else if button == "dpdown" do
            playerControllers[controllerIndex+1].finish = true
        end else do print' "Unbound button" end
    end

    love.gamepadreleased = fn joystick: l.LoveJoystick, button do
    end

    update :: fn delta do
        time = time + delta

        case scene do
            MainMenu do
            end
            Game state do
                graph.updateGraph' state.graph, delta

                // Inputs
                case state.inputState do
                    MoveUnit unit do
                        may_dir := inputDirection'
                        case may_dir do
                            Just dir do
                                state.inputState = InputState.MoveUnitDirection (unit, dir)
                            end
                            else do end
                        end
                    end

                    MoveUnitDirection tup do
                        may_dir := inputDirection'
                        case may_dir do
                            Just dir do
                                state.inputState = InputState.MoveUnitDirection (tup[0], dir)
                            end
                            else do end
                        end
                    end

                    else do end
                end

            end
            else do <!> end
        end

        playerControllers -> for_each' fn controller do
            controller.finish = false
            controller.move = false
        end
    end

    col := gfx.rgb' 1., 0., 0.

    voronoiShader :: love.graphics.newShader("res/voronoi.glsl")

    draw :: fn do
        white := gfx.rgb' 1., 1., 1.

        drawVoronoiBackground :: fn vertices: [(*, *, *)] do
            love.graphics.setShader' voronoiShader
            send_shader_graph_positions' voronoiShader, vertices
            gfx.drawRect' white, (0., 0.), (800., 600.)
            gfx.clearShader'
        end

        case scene do
            MainMenu do
                aFont.drawText' col, "Menu", (0., 0.)
            end
            Game state do
                i := 0

                state.graph.nodes -> map(fn node ->
                    faction := rem' i, 4 // TODO use actual data here

                    i = i + 1

                    ret (node.position[0], node.position[1], faction)
                end) -> drawVoronoiBackground'

                graph.drawGraph' state.graph
                state.units -> for_each' fn u do
                    unit.drawUnit' u, state.graph
                end

                case state.inputState do
                    MoveUnitDirection tup do
                        facing := graph.facingNeighbour' state.units[tup[0]].node, tup[1], state.graph
                        u := state.units[tup[0]]
                        unit.drawUnitDirection' u, facing, state.graph
                    end

                    else do end
                end

                aFont.drawText' col, "Game", (0., 0.)
            end
            else do <!> end
        end
    end

    scene = States.Game GameState {
        graph: graph.createGraph(),
        units: [unit.Unit { node: 0, },],
        inputState: InputState.MoveUnit 0,
    }

    love.keypressed = fn _key, scancode, repeat do
        key := input.strToKeyDict[_key]
        case key do
            Escape do
                print' "Quitting game..."
                love.event.quit' 0
            end else do end
        end

        case scene do
            MainMenu do
            end
            Game state do
                case state.inputState do
                    MoveUnitDirection tup do
                        case key do
                            Space do
                                unitI := tup[0]
                                facing := graph.facingNeighbour' state.units[tup[0]].node, tup[1], state.graph
                                state.units[unitI].node = facing
                            end else do end
                        end
                    end else do end
                end
            end else do <!> end
        end

        case scene do
            MainMenu do
                print("starting game")
                scene = States.Game GameState {
                    graph: graph.createGraph(),
                    units: [unit.Unit { node: 0, },],
                    inputState: InputState.MoveUnit 0,
                }
            end
            Game state do
            end
            else do <!> end
        end
    end

    love.keyreleased = fn key, scancode do
    end

    love.update = update
    love.draw = draw
end

Maybe :: enum
    Just *,
    Nothing,
end

inputDirection :: fn -> Maybe do // Maybe (float, float)
    res := (0., 0.)
    if input.isKeyDown' input.Key.Up do res += (0., -1.) end
    if input.isKeyDown' input.Key.Down do res += (0., 1.) end
    if input.isKeyDown' input.Key.Left do res += (-1., 0.) end
    if input.isKeyDown' input.Key.Right do res += (1., -0.) end
    if res == (0., 0.,) do
        ret Maybe.Nothing
    end
    ret Maybe.Just (normalize' res)
end

//use gfx
//from gfx use (stableRandomColor as rcol)
//use input
//use sfx
//
//    r := 0.
//
//    aFont :: gfx.aFont()
//    img :: gfx.newImage' "res/sylt.png"
//    ps :: gfx.newParticles' img
//    ps.setParticleLifetime(10., 10.)
//    ps.setEmissionRate(5)
//    ps.setLinearAcceleration((-40., -40.), (40., 40.))
//
//    ss :: gfx.newImplicitSpriteSheet' img, (55, 55)
//
//    s :: sfx.newSound' "res/bloop.wav", false, sfx.SoundType.Static
//
//    updates := []
//    updates -> push' fn delta do
//        if not input.isKeyDown' input.Key.A do
//            r += delta
//        end
//        if input.isKeyDown' input.Key.B do
//            sfx.cloneSound(s).playp' (1.0, 0.8), (1.0, 0.8)
//        end
//    end
//    updates -> push' fn delta do
//        pos :: input.mousePos'
//        ps.setPosition' (cos(r) * 300., sin(r) * 100.) + pos
//        ps.update(delta)
//    end
//
//    love.update = fn delta do
//        updates -> for_each' fn u: fn * -> do u(delta) end
//    end
//
//    love.draw = fn do
//        gfx.drawLine' rcol(1.), (0., 0.), (100., 100.)
//
//        gfx.drawCircle' rcol(2.), (200., 100.), 50.
//        gfx.drawCircleOutline' rcol(3.), (200., 100.), 50.
//
//        gfx.drawRect' rcol(4.), (200., 200.), (50., 50.)
//        gfx.drawRectCentered' rcol(5.), (200., 200.), (50., 50.)
//
//        gfx.drawRectOutline' rcol(5.), (200., 200.), (50., 50.)
//        gfx.drawRectCenteredOutline' rcol(6.), (200., 200.), (50., 50.)
//
//        aFont.drawText' rcol(8.), "Hello world!", (200., 200.)
//        aFont.drawTextT' rcol(9.), "Hello world!", (200., 250.), 1., 2.
//        aFont.drawTextF' rcol(10.), "Hello world!", (200., 250.), gfx.Alignment.Right, 50.
//        aFont.drawTextFT' rcol(11.), "Hello world!", (200., 250.), gfx.Alignment.Right, 50., -1., 2.
//
//        img.draw' (100., 200.), r, (1., 1.)
//        img.drawTinted' rcol(12.), (100., 200.), r + 1., (1., 1.)
//        img.drawCenterd' (100., 200.), r, (1., 1.)
//        img.drawTintedCentered' rcol(12.), (100., 200.), r + 1., (1., 1.)
//
//        ps.draw' gfx.rgb(1., 1., 1.)
//
//        ss.draw' rcol(12.), as_int(rem(r, 4.)), (100., 100.), r, (1., 1.)
//        ss.drawCenterd' rcol(13.), as_int(rem(r, 4.)), (100., 100.), r, (1., 1.)
//    end
