from /love use (love, Shader)
use /love as l
use /res/
use /input
use /gfx

use graph
use menu
use guy

from /main use varargs

newController :: fn -> Controller do
    Controller {
        joystick: (0., 0.),
        finish: false,
        move: false,
    }
end

playerControllers: [Controller] = [ newController(), newController(), ]

Controller :: blob {
    joystick: (float, float),
    finish: bool,
    move: bool,
}

States :: enum
    MainMenu menu.Menu,
    Game GameState,
end

InputState :: enum
    MoveGuy int, // guy index
    MoveGuyDirection (int, (float, float)), // guy index, direction [0, 2*pi)
end

GameState :: blob {
    graph: graph.Graph,
    guys: {int: [guy.Guy]},
    factions: [guy.Faction],
    player_turn: guy.Faction,
    moves_left: int,
    inputState: InputState,
}

send_shader_graph_positions :: fn shader: Shader, points do
    // !!!!!!!! DON'T DO THIS AT HOME !!!!!!!
    do
        v : [int] : [
            unsafe_force(shader),
            unsafe_force("vertex_positions"),
        ]
        points -> for_each' fn x do
            v -> push' unsafe_force' (x[0], x[1])
        end
        varargs(shader.send)(v)
    end

    do
        v : [int] : [
            unsafe_force(shader),
            unsafe_force("vertex_colors"),
        ]
        points -> for_each' fn x do
            v -> push' unsafe_force' x[2]
        end
        varargs(shader.send)(v)
    end

    do
        v :: [
            unsafe_force(shader),
            unsafe_force("num_vertex_positions"),
            len(points),
        ]
        varargs(shader.send)(v)
    end
end

init :: fn do

    res.loadResources()

    defaultFont :: gfx.createFont(love.graphics.getFont())
    mainMenuFont :: gfx.createFont(res.font["menu"])

    scene := States.MainMenu menu.createMenu([])
    scene = States.MainMenu menu.createMenu([
        ("Start", fn do
            scene = States.Game GameState {
                graph: graph.createGraph(),
                guys: {
                    guy.faction_to_int(guy.Faction.Blueberry): [
                        guy.new_guy(guy.Faction.Blueberry, 0),
                    ],
                    guy.faction_to_int(guy.Faction.Strawberry): [
                        guy.new_guy(guy.Faction.Strawberry, 1),
                    ],
                },
                factions: [guy.Faction.Blueberry, guy.Faction.Strawberry],
                player_turn: guy.Faction.Blueberry,
                moves_left: 1,
                inputState: InputState.MoveGuy 0,
            }
        end),
        ("Exit", fn do
            love.event.quit' 0
        end)
    ])

    time := 0.

    love.gamepadaxis = fn joystick: l.LoveJoystick, axis, size do
        controllerIndex := ((joystick.getID' joystick) - 1) / 2

        if axis == "rightx" do
            controller := playerControllers[controllerIndex]
            controller.joystick = (controller.joystick[0], size)
        end else if axis == "righty" do
            controller := playerControllers[controllerIndex]
            controller.joystick = (size, controller.joystick[1])
        end else if axis == "leftx" do
            controller := playerControllers[controllerIndex+1]
            controller.joystick = (controller.joystick[0], size)
        end else if axis == "lefty" do
            controller := playerControllers[controllerIndex+1]
            controller.joystick = (size, controller.joystick[1])
        end
    end

    love.gamepadpressed = fn joystick: l.LoveJoystick, button do
        controllerIndex := ((joystick.getID' joystick) - 1) / 2
        if button == "rightshoulder" do
            playerControllers[controllerIndex].move = true
        else if button == "a" do
            playerControllers[controllerIndex].finish = true
        else if button == "leftshoulder" do
            playerControllers[controllerIndex+1].move = true
        else if button == "dpdown" do
            playerControllers[controllerIndex+1].finish = true
        end else do print' "Unbound button" end
    end

    love.gamepadreleased = fn joystick: l.LoveJoystick, button do
    end

    update :: fn delta do
        time = time + delta

        case scene do
            MainMenu _ do
            end
            Game state do
                graph.updateGraph' state.graph, delta

                // Update animation timers
                state.factions -> for_each' fn f do
                    guys :: state.guys[guy.faction_to_int(f)]
                    guys -> for_each' fn g do
                        guy.updateGuy' g, delta
                    end
                end

                // Inputs
                case state.inputState do
                    MoveGuy guy do
                        may_dir := inputDirection'
                        case may_dir do
                            Just dir do
                                state.inputState = InputState.MoveGuyDirection (guy, dir)
                            end
                            else do end
                        end
                    end

                    MoveGuyDirection tup do
                        may_dir := inputDirection'
                        case may_dir do
                            Just dir do
                                state.inputState = InputState.MoveGuyDirection (tup[0], dir)
                            end
                            else do end
                        end
                    end

                    else do end
                end

            end
            else do <!> end
        end

        playerControllers -> for_each' fn controller do
            controller.finish = false
            controller.move = false
        end
    end


    col := gfx.rgb' 1., 0., 0.

    voronoiShader :: love.graphics.newShader("res/voronoi.glsl")

    draw :: fn do
        white := gfx.rgb' 1., 1., 1.

        drawVoronoiBackground :: fn vertices: [(*, *, *)] do
            love.graphics.setShader' voronoiShader
            send_shader_graph_positions' voronoiShader, vertices
            gfx.drawRect' white, (0., 0.), (800., 600.)
            gfx.clearShader'
        end

        case scene do
            MainMenu menu do
                BACKGROUND_COLOR :: gfx.rgb' 50. / 255., 50. / 255., 50. / 255.
                gfx.drawRect' BACKGROUND_COLOR, (0., 0.), gfx.screenSizef()

                MENU_COLOR :: gfx.rgb' 1., 1., 1.
                HEADER_COLOR :: gfx.rgb' 209. / 255., 59. / 255., 57. / 255.
                SELECTED_COLOR :: gfx.rgb' 229. / 255., 126. / 255., 124. / 255.
                MENU_SIZE :: 1.
                MIDDLE :: gfx.screenSizef() / (2., 2.)

                // Header
                headerBox :: (600.0, 0.0)
                mainMenuFont.drawTextFT(
                    HEADER_COLOR,
                    "Age of Sylt",
                    MIDDLE  - headerBox / (2., 2.) - (0., 250.),
                    gfx.Alignment.Center,
                    600.0,
                    0.0,
                    MENU_SIZE
                )

                // Choices
                choiceBox :: (300.0, 0.0)
                offset := (0.0, -80.)
                i := 0
                menu.choices -> for_each' fn choice do
                    color := MENU_COLOR
                    if i == menu.position do
                        color = SELECTED_COLOR
                    end

                    mainMenuFont.drawTextFT(
                        color,
                        choice[0],
                        MIDDLE - choiceBox / (2., 2.) + offset,
                        gfx.Alignment.Center,
                        choiceBox[0],
                        0.0,
                        MENU_SIZE
                    )
                    offset += (0.0, 80.0)
                    i += 1
                end

                // Crests
                B_OFFEST :: (200., 0.)
                C_OFFSET :: (-200., 0.)
                G_OFFSET :: (100., 200.)
                S_OFFSET :: (-100., 200.)
                SCALE :: (2.0, 2.0)
                guy.crest_image(guy.Faction.Blueberry).drawCentered' MIDDLE + B_OFFEST, 0.0, SCALE
                guy.crest_image(guy.Faction.Cloudberry).drawCentered' MIDDLE + C_OFFSET, 0.0, SCALE
                guy.crest_image(guy.Faction.Gooseberry).drawCentered' MIDDLE + G_OFFSET, 0.0, SCALE
                guy.crest_image(guy.Faction.Strawberry).drawCentered' MIDDLE + S_OFFSET, 0.0, SCALE
            end
            Game state do
                i := 0

                state.graph.nodes -> map(fn node ->
                    faction := rem' i, 4 // TODO use actual data here

                    i = i + 1

                    ret (node.position[0], node.position[1], faction)
                end) -> drawVoronoiBackground'

                graph.drawGraph' state.graph

                state.factions -> for_each' fn f do
                    guys :: state.guys[guy.faction_to_int(f)]
                    guys -> for_each' fn g do
                        guy.drawGuy' g, state.graph
                    end
                end

                case state.inputState do
                    MoveGuyDirection tup do
                        g :: state.guys[guy.faction_to_int(state.player_turn)][tup[0]]
                        facing :: graph.facingNeighbour' g.node, tup[1], state.graph
                        guy.drawGuyDirection' g, facing, state.graph
                    end

                    else do end
                end

                defaultFont.drawText' col, "Game", (0., 0.)
            end
            else do <!> end
        end
    end

    next_turn :: fn state do
        mod :: len' state.factions
        i :: rem' guy.faction_to_int(state.player_turn) + 1, mod
        faction :: state.factions[i]

        state.player_turn = faction
        guys :: state.guys[guy.faction_to_int(faction)]
        guy_index :: love.math.random(0, len(guys) - 1)
        state.inputState = InputState.MoveGuy guy_index
        state.moves_left = 1

        // TODO spawn guys etc
    end

    post_move :: fn state do
        if state.moves_left > 0 do
            case state.inputState do
                MoveGuyDirection tup do
                    gi :: tup[0]
                    state.inputState = InputState.MoveGuy gi
                end
                else do <!> end
            end

            state.moves_left = state.moves_left - 1
        else do
            next_turn' state
        end
    end

    love.keypressed = fn _key, scancode, repeat do
        key := input.strToKeyDict[_key]
        case key do
            Escape do
                print' "Quitting game..."
                love.event.quit' 0
            end else do end
        end

        case scene do
            MainMenu menu do
                case key do
                    Return do
                        menu.select()
                    end
                    Space do
                        menu.select()
                    end
                    Up do
                        menu.up()
                    end
                    Down do
                        menu.down()
                    end
                    else do end
                end
            end
            Game state do
                case state.inputState do
                    MoveGuyDirection tup do
                        case key do
                            Space do
                                guyI :: tup[0]
                                dir :: tup[1]
                                g :: state.guys[guy.faction_to_int(state.player_turn)][guyI]
                                g.node = graph.facingNeighbour' g.node, dir, state.graph

                                post_move' state
                            end
                            else do end
                        end
                    end else do end
                end
            end else do <!> end
        end
    end

    love.keyreleased = fn key, scancode do
    end

    love.update = update
    love.draw = draw
end

Maybe :: enum
    Just *,
    Nothing,
end

inputDirection :: fn -> Maybe do // Maybe (float, float)
    res := (0., 0.)
    if input.isKeyDown' input.Key.Up do res += (0., -1.) end
    if input.isKeyDown' input.Key.Down do res += (0., 1.) end
    if input.isKeyDown' input.Key.Left do res += (-1., 0.) end
    if input.isKeyDown' input.Key.Right do res += (1., -0.) end
    if res == (0., 0.,) do
        ret Maybe.Nothing
    end
    ret Maybe.Just (normalize' res)
end

//use gfx
//from gfx use (stableRandomColor as rcol)
//use input
//use sfx
//
//    r := 0.
//
//    aFont :: gfx.aFont()
//    img :: gfx.newImage' "res/sylt.png"
//    ps :: gfx.newParticles' img
//    ps.setParticleLifetime(10., 10.)
//    ps.setEmissionRate(5)
//    ps.setLinearAcceleration((-40., -40.), (40., 40.))
//
//    ss :: gfx.newImplicitSpriteSheet' img, (55, 55)
//
//    s :: sfx.newSound' "res/bloop.wav", false, sfx.SoundType.Static
//
//    updates := []
//    updates -> push' fn delta do
//        if not input.isKeyDown' input.Key.A do
//            r += delta
//        end
//        if input.isKeyDown' input.Key.B do
//            sfx.cloneSound(s).playp' (1.0, 0.8), (1.0, 0.8)
//        end
//    end
//    updates -> push' fn delta do
//        pos :: input.mousePos'
//        ps.setPosition' (cos(r) * 300., sin(r) * 100.) + pos
//        ps.update(delta)
//    end
//
//    love.update = fn delta do
//        updates -> for_each' fn u: fn * -> do u(delta) end
//    end
//
//    love.draw = fn do
//        gfx.drawLine' rcol(1.), (0., 0.), (100., 100.)
//
//        gfx.drawCircle' rcol(2.), (200., 100.), 50.
//        gfx.drawCircleOutline' rcol(3.), (200., 100.), 50.
//
//        gfx.drawRect' rcol(4.), (200., 200.), (50., 50.)
//        gfx.drawRectCentered' rcol(5.), (200., 200.), (50., 50.)
//
//        gfx.drawRectOutline' rcol(5.), (200., 200.), (50., 50.)
//        gfx.drawRectCenteredOutline' rcol(6.), (200., 200.), (50., 50.)
//
//        aFont.drawText' rcol(8.), "Hello world!", (200., 200.)
//        aFont.drawTextT' rcol(9.), "Hello world!", (200., 250.), 1., 2.
//        aFont.drawTextF' rcol(10.), "Hello world!", (200., 250.), gfx.Alignment.Right, 50.
//        aFont.drawTextFT' rcol(11.), "Hello world!", (200., 250.), gfx.Alignment.Right, 50., -1., 2.
//
//        img.draw' (100., 200.), r, (1., 1.)
//        img.drawTinted' rcol(12.), (100., 200.), r + 1., (1., 1.)
//        img.drawCenterd' (100., 200.), r, (1., 1.)
//        img.drawTintedCentered' rcol(12.), (100., 200.), r + 1., (1., 1.)
//
//        ps.draw' gfx.rgb(1., 1., 1.)
//
//        ss.draw' rcol(12.), as_int(rem(r, 4.)), (100., 100.), r, (1., 1.)
//        ss.drawCenterd' rcol(13.), as_int(rem(r, 4.)), (100., 100.), r, (1., 1.)
//    end
