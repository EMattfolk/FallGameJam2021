from /love use (love, Shader)
use /love as l
use /res/
use /input
use /gfx

use graph
use menu
use guy

from /main use varargs

clone :: fn list ->
    c :: []
    list -> for_each' fn x ->
        c -> push' x
    end
    ret c
end

guy_to_move :: fn state ->
    ret state.guys_to_move[guy.faction_to_int(state.player_turn)] -> last'
end

makeFullscreen :: fn do
    w := l.WindowFlags {
        fullscreen: true,
        fullscreentype: "desktop",
        vsync: 0,
        msaa: 2,
        resizable: false,
        borderless: false,
        centered: false,
        display: 0,
        minwidth: 100,
        minheight: 100,
    }
    love.window.setMode' 0, 0, w
end

newController :: fn -> Controller do
    Controller {
        joystick: (0., 0.),
        finish: false,
        move: false,
    }
end

playerControllers: [Controller] = [ newController(), newController(), ]

Controller :: blob {
    joystick: (float, float),
    finish: bool,
    move: bool,
}

States :: enum
    MainMenu menu.Menu,
    Game GameState,
end

InputState :: enum
    MoveGuy,
    MoveGuyDirection (float, float), // direction xy
end

GameState :: blob {
    graph: graph.Graph,
    guys: {int: [guy.Guy]},
    guys_to_move: {int: [guy.Guy]},
    factions: [guy.Faction],
    player_turn: guy.Faction,
    moves_left: int,
    inputState: InputState,
}

send_shader_graph_positions :: fn shader: Shader, points do
    // !!!!!!!! DON'T DO THIS AT HOME !!!!!!!
    do
        v : [int] : [
            unsafe_force(shader),
            unsafe_force("vertex_positions"),
        ]
        points -> for_each' fn x do
            v -> push' unsafe_force' (x[0], x[1])
        end
        varargs(shader.send)(v)
    end

    do
        v : [int] : [
            unsafe_force(shader),
            unsafe_force("vertex_colors"),
        ]
        points -> for_each' fn x do
            v -> push' unsafe_force' x[2]
        end
        varargs(shader.send)(v)
    end

    do
        v :: [
            unsafe_force(shader),
            unsafe_force("num_vertex_positions"),
            len(points),
        ]
        varargs(shader.send)(v)
    end
end

init :: fn do
    makeFullscreen'

    res.loadResources()

    defaultFont :: gfx.createFont(love.graphics.getFont())
    mainMenuFont :: gfx.createFont(res.font["menu"])

    scene := States.MainMenu menu.createMenu([])
    scene = States.MainMenu menu.createMenu([
        ("Start", fn do
            blue_guys :: [
                guy.new_guy(guy.Faction.Blueberry, 7),
            ]
            cloud_guys :: [
                guy.new_guy(guy.Faction.Cloudberry, 13),
            ]
            state :: GameState {
                graph: graph.createGraph(),
                guys: {
                    guy.faction_to_int(guy.Faction.Blueberry): blue_guys,
                    guy.faction_to_int(guy.Faction.Cloudberry): cloud_guys,
                },
                guys_to_move: {
                    guy.faction_to_int(guy.Faction.Blueberry): blue_guys,
                    guy.faction_to_int(guy.Faction.Cloudberry): cloud_guys,
                },
                factions: [guy.Faction.Blueberry, guy.Faction.Cloudberry],
                player_turn: guy.Faction.Blueberry,
                moves_left: 1,
                inputState: InputState.MoveGuy,
            }
            state.factions -> for_each' fn faction do
                fi :: guy.faction_to_int' faction

                state.guys_to_move[fi] = state.guys[fi] -> clone'
            end

            scene = States.Game state
        end),
        ("Exit", fn do
            love.event.quit' 0
        end)
    ])

    time := 0.

    love.gamepadaxis = fn joystick: l.LoveJoystick, axis, size do
        controllerIndex := ((joystick.getID' joystick) - 1) / 2

        if axis == "rightx" do
            controller := playerControllers[controllerIndex]
            controller.joystick = (controller.joystick[0], size)
        end else if axis == "righty" do
            controller := playerControllers[controllerIndex]
            controller.joystick = (size, controller.joystick[1])
        end else if axis == "leftx" do
            controller := playerControllers[controllerIndex+1]
            controller.joystick = (controller.joystick[0], size)
        end else if axis == "lefty" do
            controller := playerControllers[controllerIndex+1]
            controller.joystick = (size, controller.joystick[1])
        end
    end

    love.gamepadpressed = fn joystick: l.LoveJoystick, button do
        controllerIndex := ((joystick.getID' joystick) - 1) / 2
        if button == "rightshoulder" do
            playerControllers[controllerIndex].move = true
        else if button == "a" do
            playerControllers[controllerIndex].finish = true
        else if button == "leftshoulder" do
            playerControllers[controllerIndex+1].move = true
        else if button == "dpdown" do
            playerControllers[controllerIndex+1].finish = true
        end else do print' "Unbound button" end
    end

    love.gamepadreleased = fn joystick: l.LoveJoystick, button do
    end

    update :: fn delta do
        time = time + delta

        case scene do
            MainMenu _ do
            end
            Game state do
                graph.updateGraph' state.graph, delta

                // Update animation timers
                state.factions -> for_each' fn f do
                    guys :: state.guys_to_move[guy.faction_to_int(f)]
                    guys -> for_each' fn g do
                        guy.updateGuy' g, delta
                    end
                end

                // Inputs
                case state.inputState do
                    MoveGuy do
                        may_dir := inputDirection'
                        case may_dir do
                            Just dir do
                                state.inputState = InputState.MoveGuyDirection dir
                            end
                            else do end
                        end
                    end

                    MoveGuyDirection _ do
                        may_dir := inputDirection'
                        case may_dir do
                            Just dir do
                                state.inputState = InputState.MoveGuyDirection dir
                            end
                            else do end
                        end
                    end

                    else do end
                end

            end
            else do <!> end
        end

        playerControllers -> for_each' fn controller do
            controller.finish = false
            controller.move = false
        end
    end


    col := gfx.rgb' 1., 0., 0.

    voronoiShader :: love.graphics.newShader("res/voronoi.glsl")

    draw :: fn do
        white := gfx.rgb' 1., 1., 1.

        drawVoronoiBackground :: fn vertices: [(*, *, *)] do
            love.graphics.setShader' voronoiShader
            send_shader_graph_positions' voronoiShader, vertices
            gfx.drawRect' white, (0., 0.), (as_float(love.graphics.getWidth'), as_float(love.graphics.getHeight'))
            gfx.clearShader'
        end

        case scene do
            MainMenu menu do
                BACKGROUND_COLOR :: gfx.rgb' 50. / 255., 50. / 255., 50. / 255.
                gfx.drawRect' BACKGROUND_COLOR, (0., 0.), gfx.screenSizef()

                MENU_COLOR :: gfx.rgb' 1., 1., 1.
                HEADER_COLOR :: gfx.rgb' 209. / 255., 59. / 255., 57. / 255.
                SELECTED_COLOR :: gfx.rgb' 229. / 255., 126. / 255., 124. / 255.
                MENU_SIZE :: 1.
                MIDDLE :: gfx.screenSizef() / (2., 2.)

                // Header
                headerBox :: (600.0, 0.0)
                mainMenuFont.drawTextFT(
                    HEADER_COLOR,
                    "Age of Sylt",
                    MIDDLE  - headerBox / (2., 2.) - (0., 250.),
                    gfx.Alignment.Center,
                    600.0,
                    0.0,
                    MENU_SIZE
                )

                // Choices
                choiceBox :: (300.0, 0.0)
                offset := (0.0, -80.)
                i := 0
                menu.choices -> for_each' fn choice do
                    color := MENU_COLOR
                    if i == menu.position do
                        color = SELECTED_COLOR
                    end

                    mainMenuFont.drawTextFT(
                        color,
                        choice[0],
                        MIDDLE - choiceBox / (2., 2.) + offset,
                        gfx.Alignment.Center,
                        choiceBox[0],
                        0.0,
                        MENU_SIZE
                    )
                    offset += (0.0, 80.0)
                    i += 1
                end

                // Crests
                B_OFFEST :: (200., 0.)
                C_OFFSET :: (-200., 0.)
                G_OFFSET :: (100., 200.)
                S_OFFSET :: (-100., 200.)
                SCALE :: (2.0, 2.0)
                guy.crest_image(guy.Faction.Blueberry).drawCentered' MIDDLE + B_OFFEST, 0.0, SCALE
                guy.crest_image(guy.Faction.Cloudberry).drawCentered' MIDDLE + C_OFFSET, 0.0, SCALE
                guy.crest_image(guy.Faction.Gooseberry).drawCentered' MIDDLE + G_OFFSET, 0.0, SCALE
                guy.crest_image(guy.Faction.Strawberry).drawCentered' MIDDLE + S_OFFSET, 0.0, SCALE
            end
            Game state do
                i := 0

                offset :: graph.graphCenter' state.graph

                state.graph.nodes -> map(fn node ->
                    faction := graph.shaderColor(node)

                    i = i + 1

                    ret (node.position[0] + offset[0], node.position[1] + offset[1], faction)
                end) -> drawVoronoiBackground'

                love.graphics.translate' offset[0], offset[1]
                do
                    graph.drawGraph' state.graph

                    state.factions -> for_each' fn f do
                        guys :: state.guys[guy.faction_to_int(f)]
                        guys -> for_each' fn g do
                            guy.drawGuy' g, state.graph
                        end
                    end

                    case state.inputState do
                        MoveGuyDirection dir do
                            g :: state -> guy_to_move'
                            facing :: graph.facingNeighbour' g.node, dir, state.graph
                            guy.drawGuyDirection' g, facing, state.graph
                        end
                        else do end
                    end
                end
                love.graphics.origin'
            end
            else do <!> end
        end
    end

    faction_start_round :: fn state do
        fi :: guy.faction_to_int' state.player_turn

        to_move :: state.guys_to_move[fi]

        guys :: state.guys[fi]

        if len(to_move) == 0 do
            i := 0
            loop i < len(state.graph.nodes) do
                spawn :: fn faction do
                    if faction == state.player_turn do
                        guys -> push' guy.new_guy(faction, i)
                    end
                end

                case state.graph.nodes[i].tile do
                    Base faction do
                        spawn' faction
                    end
                    Factory faction do
                        spawn' faction
                    end
                    else do end
                end
                i = i + 1
            end

            state.guys_to_move[fi] = guys -> clone' // TODO shuffle
        end
    end

    next_turn :: fn state do
        faction_i :: guy.faction_to_int' state.player_turn
        state.guys_to_move[faction_i] -> pop'

        num_factions :: len' state.factions
        next_faction_i :: faction_i + 1
        i :: rem' next_faction_i, num_factions

        state.player_turn = state.factions[i]
        state.moves_left = 1
        state.inputState = InputState.MoveGuy

        state -> faction_start_round'
    end

    post_move :: fn state do
        if state.moves_left > 0 do
            case state.inputState do
                MoveGuyDirection _ do
                    state.inputState = InputState.MoveGuy
                end
                else do <!> end
            end

            state.moves_left = state.moves_left - 1
        else do
            next_turn' state
        end
    end

    love.keypressed = fn _key, scancode, repeat do
        key := input.strToKeyDict[_key]
        case key do
            Escape do
                print' "Quitting game..."
                love.event.quit' 0
            end else do end
        end

        case scene do
            MainMenu menu do
                case key do
                    Return do
                        menu.select()
                    end
                    Space do
                        menu.select()
                    end
                    Up do
                        menu.up()
                    end
                    Down do
                        menu.down()
                    end
                    else do end
                end
            end
            Game state do
                case state.inputState do
                    MoveGuyDirection dir do
                        case key do
                            Space do
                                g :: state -> guy_to_move'
                                g.node = graph.facingNeighbour' g.node, dir, state.graph

                                state.factions -> for_each' fn other_fn do
                                    if g.faction == other_fn ret

                                    fn_guys := state.guys[guy.faction_to_int(other_fn)]

                                    kill := false
                                    state.guys[guy.faction_to_int(other_fn)] = fn_guys -> filter' fn other_guy -> do
                                        if other_guy.node == g.node and not kill do
                                            kill = true
                                            ret false
                                        else do
                                            ret true
                                        end
                                    end

                                    if kill do
                                        state.guys[guy.faction_to_int(g.faction)] = state.guys[guy.faction_to_int(g.faction)] -> filter' fn guy -> do
                                            guy != g
                                        end
                                    end
                                end

                                post_move' state
                            end
                            else do end
                        end
                    end else do end
                end
            end else do <!> end
        end
    end

    love.keyreleased = fn key, scancode do
    end

    love.update = update
    love.draw = draw
end

Maybe :: enum
    Just *,
    Nothing,
end

inputDirection :: fn -> Maybe do // Maybe (float, float)
    res := (0., 0.)
    if input.isKeyDown' input.Key.Up do res += (0., -1.) end
    if input.isKeyDown' input.Key.Down do res += (0., 1.) end
    if input.isKeyDown' input.Key.Left do res += (-1., 0.) end
    if input.isKeyDown' input.Key.Right do res += (1., -0.) end
    if res == (0., 0.,) do
        ret Maybe.Nothing
    end
    ret Maybe.Just (normalize' res)
end

//use gfx
//from gfx use (stableRandomColor as rcol)
//use input
//use sfx
//
//    r := 0.
//
//    aFont :: gfx.aFont()
//    img :: gfx.newImage' "res/sylt.png"
//    ps :: gfx.newParticles' img
//    ps.setParticleLifetime(10., 10.)
//    ps.setEmissionRate(5)
//    ps.setLinearAcceleration((-40., -40.), (40., 40.))
//
//    ss :: gfx.newImplicitSpriteSheet' img, (55, 55)
//
//    s :: sfx.newSound' "res/bloop.wav", false, sfx.SoundType.Static
//
//    updates := []
//    updates -> push' fn delta do
//        if not input.isKeyDown' input.Key.A do
//            r += delta
//        end
//        if input.isKeyDown' input.Key.B do
//            sfx.cloneSound(s).playp' (1.0, 0.8), (1.0, 0.8)
//        end
//    end
//    updates -> push' fn delta do
//        pos :: input.mousePos'
//        ps.setPosition' (cos(r) * 300., sin(r) * 100.) + pos
//        ps.update(delta)
//    end
//
//    love.update = fn delta do
//        updates -> for_each' fn u: fn * -> do u(delta) end
//    end
//
//    love.draw = fn do
//        gfx.drawLine' rcol(1.), (0., 0.), (100., 100.)
//
//        gfx.drawCircle' rcol(2.), (200., 100.), 50.
//        gfx.drawCircleOutline' rcol(3.), (200., 100.), 50.
//
//        gfx.drawRect' rcol(4.), (200., 200.), (50., 50.)
//        gfx.drawRectCentered' rcol(5.), (200., 200.), (50., 50.)
//
//        gfx.drawRectOutline' rcol(5.), (200., 200.), (50., 50.)
//        gfx.drawRectCenteredOutline' rcol(6.), (200., 200.), (50., 50.)
//
//        aFont.drawText' rcol(8.), "Hello world!", (200., 200.)
//        aFont.drawTextT' rcol(9.), "Hello world!", (200., 250.), 1., 2.
//        aFont.drawTextF' rcol(10.), "Hello world!", (200., 250.), gfx.Alignment.Right, 50.
//        aFont.drawTextFT' rcol(11.), "Hello world!", (200., 250.), gfx.Alignment.Right, 50., -1., 2.
//
//        img.draw' (100., 200.), r, (1., 1.)
//        img.drawTinted' rcol(12.), (100., 200.), r + 1., (1., 1.)
//        img.drawCenterd' (100., 200.), r, (1., 1.)
//        img.drawTintedCentered' rcol(12.), (100., 200.), r + 1., (1., 1.)
//
//        ps.draw' gfx.rgb(1., 1., 1.)
//
//        ss.draw' rcol(12.), as_int(rem(r, 4.)), (100., 100.), r, (1., 1.)
//        ss.drawCenterd' rcol(13.), as_int(rem(r, 4.)), (100., 100.), r, (1., 1.)
//    end
