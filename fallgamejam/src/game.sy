from /love use (love, Shader)
use /res/
use /input
use /gfx

use graph
use unit

from /main use varargs

States :: enum
    MainMenu *,
    Game GameState,
end

InputState :: enum
    None,
    MoveUnit int, // unit index
    MoveUnitDirection (int, (float, float)), // unit index, direction [0, 2*pi)
end

GameState :: blob {
    graph: graph.Graph,
    units: [unit.Unit],
    inputState: InputState,
}

send_shader_graph_positions :: fn shader: Shader, points do
    // !!!!!!!! DON'T DO THIS AT HOME !!!!!!!
    do
        v : [int] : [
            unsafe_force(shader),
            unsafe_force("vertex_positions"),
        ]
        points -> for_each' fn x do
            v -> push' unsafe_force' (x[0], x[1])
        end
        varargs(shader.send)(v)
    end

    do
        v : [int] : [
            unsafe_force(shader),
            unsafe_force("vertex_colors"),
        ]
        points -> for_each' fn x do
            v -> push' unsafe_force' x[2]
        end
        varargs(shader.send)(v)
    end

    do
        v :: [
            unsafe_force(shader),
            unsafe_force("num_vertex_positions"),
            len(points),
        ]
        varargs(shader.send)(v)
    end
end

init :: fn do

    aFont :: gfx.aFont()

    scene := States.MainMenu
    time := 0.

    update :: fn delta do
        time = time + delta

        case scene do
            MainMenu do
            end
            Game state do
                graph.updateGraph' state.graph, delta

                // Inputs
                case state.inputState do
                    MoveUnit unit do
                        may_dir := inputDirection'
                        case may_dir do
                            Just dir do
                                state.inputState = InputState.MoveUnitDirection (unit, dir)
                            end
                            else do end
                        end
                    end

                    MoveUnitDirection tup do
                        may_dir := inputDirection'
                        case may_dir do
                            Just dir do
                                state.inputState = InputState.MoveUnitDirection (tup[0], dir)
                            end
                            else do end
                        end
                    end

                    else do end
                end

            end
            else do <!> end
        end
    end

    col := gfx.rgb' 1., 0., 0.

    voronoiShader :: love.graphics.newShader("res/voronoi.glsl")

    draw :: fn do
        white := gfx.rgb' 1., 1., 1.

        vertices :: [
            (
                100. + cos(time) * 50.,
                100. + sin(time) * 30.,
                1,
            ),
            (
                200. + cos(5.2 * time) * 50.,
                200. + sin(time) * 30.,
                0,
            ),
            (
                300. + cos(1.4 * time) * 50.,
                100. + sin(time) * 30.,
                2,
            ),
            (
                400. + cos(2. * time) * 50.,
                300. + sin(2. * time) * 30.,
                3,
            ),
        ]

        love.graphics.setShader' voronoiShader
        send_shader_graph_positions' voronoiShader, vertices
        gfx.drawRect' white, (0., 0.), (800., 600.)
        gfx.clearShader'

        case scene do
            MainMenu do
                aFont.drawText' col, "Menu", (0., 0.)
            end
            Game state do
                graph.drawGraph' state.graph
                state.units -> for_each' fn u do
                    unit.drawUnit' u, state.graph
                end

                case state.inputState do
                    MoveUnitDirection tup do
                        facing := graph.facingNeighbour' tup[0], tup[1], state.graph
                        u := state.units[tup[0]]
                        unit.drawUnitDirection' u, facing, state.graph
                    end

                    else do end
                end

                aFont.drawText' col, "Game", (0., 0.)
            end
            else do <!> end
        end
    end

    scene = States.Game GameState {
        graph: graph.createGraph(),
        units: [unit.Unit { node: 0, },],
        inputState: InputState.MoveUnit 0,
    }

    love.keypressed = fn key, scancode, repeat do
        case input.strToKeyDict[key] do
            Escape do
                print' "Quitting game..."
                love.event.quit' 0
            end
            Space do
                case scene do
                    Game state do
                        case state.inputState do
                            MoveUnitDirection tup do
                                unitI := tup[0]
                                facing := graph.facingNeighbour' tup[0], tup[1], state.graph
                                state.units[unitI].node = facing
                            end
                            else do end
                        end
                    end else do end
                end
            end else do end
        end

        case scene do
            MainMenu do
                print("starting game")
                scene = States.Game GameState {
                    graph: graph.createGraph(),
                    units: [unit.Unit { node: 0, },],
                    inputState: InputState.MoveUnit 0,
                }
            end
            Game state do
            end
            else do <!> end
        end
    end

    love.keyreleased = fn key, scancode do
    end

    love.update = update
    love.draw = draw
end

Maybe :: enum
    Just *,
    Nothing,
end

inputDirection :: fn -> Maybe do // Maybe (float, float)
    res := (0., 0.)
    if input.isKeyDown' input.Key.Up do res += (0., -1.) end
    if input.isKeyDown' input.Key.Down do res += (0., 1.) end
    if input.isKeyDown' input.Key.Left do res += (-1., 0.) end
    if input.isKeyDown' input.Key.Right do res += (1., -0.) end
    if res == (0., 0.,) do
        ret Maybe.Nothing
    end
    ret Maybe.Just (normalize' res)
end

//use gfx
//from gfx use (stableRandomColor as rcol)
//use input
//use sfx
//
//    r := 0.
//
//    aFont :: gfx.aFont()
//    img :: gfx.newImage' "res/sylt.png"
//    ps :: gfx.newParticles' img
//    ps.setParticleLifetime(10., 10.)
//    ps.setEmissionRate(5)
//    ps.setLinearAcceleration((-40., -40.), (40., 40.))
//
//    ss :: gfx.newImplicitSpriteSheet' img, (55, 55)
//
//    s :: sfx.newSound' "res/bloop.wav", false, sfx.SoundType.Static
//
//    updates := []
//    updates -> push' fn delta do
//        if not input.isKeyDown' input.Key.A do
//            r += delta
//        end
//        if input.isKeyDown' input.Key.B do
//            sfx.cloneSound(s).playp' (1.0, 0.8), (1.0, 0.8)
//        end
//    end
//    updates -> push' fn delta do
//        pos :: input.mousePos'
//        ps.setPosition' (cos(r) * 300., sin(r) * 100.) + pos
//        ps.update(delta)
//    end
//
//    love.update = fn delta do
//        updates -> for_each' fn u: fn * -> do u(delta) end
//    end
//
//    love.draw = fn do
//        gfx.drawLine' rcol(1.), (0., 0.), (100., 100.)
//
//        gfx.drawCircle' rcol(2.), (200., 100.), 50.
//        gfx.drawCircleOutline' rcol(3.), (200., 100.), 50.
//
//        gfx.drawRect' rcol(4.), (200., 200.), (50., 50.)
//        gfx.drawRectCentered' rcol(5.), (200., 200.), (50., 50.)
//
//        gfx.drawRectOutline' rcol(5.), (200., 200.), (50., 50.)
//        gfx.drawRectCenteredOutline' rcol(6.), (200., 200.), (50., 50.)
//
//        aFont.drawText' rcol(8.), "Hello world!", (200., 200.)
//        aFont.drawTextT' rcol(9.), "Hello world!", (200., 250.), 1., 2.
//        aFont.drawTextF' rcol(10.), "Hello world!", (200., 250.), gfx.Alignment.Right, 50.
//        aFont.drawTextFT' rcol(11.), "Hello world!", (200., 250.), gfx.Alignment.Right, 50., -1., 2.
//
//        img.draw' (100., 200.), r, (1., 1.)
//        img.drawTinted' rcol(12.), (100., 200.), r + 1., (1., 1.)
//        img.drawCenterd' (100., 200.), r, (1., 1.)
//        img.drawTintedCentered' rcol(12.), (100., 200.), r + 1., (1., 1.)
//
//        ps.draw' gfx.rgb(1., 1., 1.)
//
//        ss.draw' rcol(12.), as_int(rem(r, 4.)), (100., 100.), r, (1., 1.)
//        ss.drawCenterd' rcol(13.), as_int(rem(r, 4.)), (100., 100.), r, (1., 1.)
//    end
