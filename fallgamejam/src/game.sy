from /love use (love, Shader)
use /res/
use /input
use /gfx

use graph
use unit
use menu

from /main use varargs

States :: enum
    MainMenu menu.Menu,
    Game GameState,
end

InputState :: enum
    None,
    MoveUnit int, // unit index
    MoveUnitDirection (int, (float, float)), // unit index, direction [0, 2*pi)
end

GameState :: blob {
    graph: graph.Graph,
    units: [unit.Unit],
    inputState: InputState,
}

send_shader_graph_positions :: fn shader: Shader, points do
    // !!!!!!!! DON'T DO THIS AT HOME !!!!!!!
    do
        v : [int] : [
            unsafe_force(shader),
            unsafe_force("vertex_positions"),
        ]
        points -> for_each' fn x do
            v -> push' unsafe_force' (x[0], x[1])
        end
        varargs(shader.send)(v)
    end

    do
        v : [int] : [
            unsafe_force(shader),
            unsafe_force("vertex_colors"),
        ]
        points -> for_each' fn x do
            v -> push' unsafe_force' x[2]
        end
        varargs(shader.send)(v)
    end

    do
        v :: [
            unsafe_force(shader),
            unsafe_force("num_vertex_positions"),
            len(points),
        ]
        varargs(shader.send)(v)
    end
end

init :: fn do

    res.loadResources()

    defaultFont :: gfx.createFont(love.graphics.getFont())
    mainMenuFont :: gfx.createFont(res.font["menu"])

    scene := States.MainMenu menu.createMenu([])
    scene = States.MainMenu menu.createMenu([
        ("Start", fn do
            scene = States.Game GameState {
                graph: graph.createGraph(),
                units: [unit.Unit { node: 0, },],
                inputState: InputState.MoveUnit 0,
            }
        end),
        ("Exit", fn do
            love.event.quit' 0
        end)
    ])

    time := 0.

    update :: fn delta do
        time = time + delta

        case scene do
            MainMenu _ do
            end
            Game state do
                graph.updateGraph' state.graph, delta

                // Inputs
                case state.inputState do
                    MoveUnit unit do
                        may_dir := inputDirection'
                        case may_dir do
                            Just dir do
                                state.inputState = InputState.MoveUnitDirection (unit, dir)
                            end
                            else do end
                        end
                    end

                    MoveUnitDirection tup do
                        may_dir := inputDirection'
                        case may_dir do
                            Just dir do
                                state.inputState = InputState.MoveUnitDirection (tup[0], dir)
                            end
                            else do end
                        end
                    end

                    else do end
                end

            end
            else do <!> end
        end
    end


    col := gfx.rgb' 1., 0., 0.

    voronoiShader :: love.graphics.newShader("res/voronoi.glsl")

    draw :: fn do
        white := gfx.rgb' 1., 1., 1.

        drawVoronoiBackground :: fn vertices: [(*, *, *)] do
            love.graphics.setShader' voronoiShader
            send_shader_graph_positions' voronoiShader, vertices
            gfx.drawRect' white, (0., 0.), (800., 600.)
            gfx.clearShader'
        end

        case scene do
            MainMenu menu do
                BACKGROUND_COLOR :: gfx.rgb' 50. / 255., 50. / 255., 50. / 255.
                gfx.drawRect' BACKGROUND_COLOR, (0., 0.), gfx.screenSizef()

                MENU_COLOR :: gfx.rgb' 1., 1., 1.
                HEADER_COLOR :: gfx.rgb' 209. / 255., 59. / 255., 57. / 255.
                SELECTED_COLOR :: gfx.rgb' 229. / 255., 126. / 255., 124. / 255.
                MENU_SIZE :: 1.
                MIDDLE :: gfx.screenSizef() / (2., 2.)

                // Header
                headerBox :: (600.0, 0.0)
                mainMenuFont.drawTextFT(
                    HEADER_COLOR,
                    "Age of Sylt",
                    MIDDLE  - headerBox / (2., 2.) - (0., 250.),
                    gfx.Alignment.Center,
                    600.0,
                    0.0,
                    MENU_SIZE
                )

                // Choices
                choiceBox :: (300.0, 0.0)
                offset := (0.0, -80.)
                i := 0
                menu.choices -> for_each' fn choice do
                    color := MENU_COLOR
                    if i == menu.position do
                        color = SELECTED_COLOR
                    end

                    mainMenuFont.drawTextFT(
                        color,
                        choice[0],
                        MIDDLE - choiceBox / (2., 2.) + offset,
                        gfx.Alignment.Center,
                        choiceBox[0],
                        0.0,
                        MENU_SIZE
                    )
                    offset += (0.0, 80.0)
                    i += 1
                end
            end
            Game state do
                i := 0

                state.graph.nodes -> map(fn node ->
                    faction := rem' i, 4 // TODO use actual data here

                    i = i + 1

                    ret (node.position[0], node.position[1], faction)
                end) -> drawVoronoiBackground'

                graph.drawGraph' state.graph
                state.units -> for_each' fn u do
                    unit.drawUnit' u, state.graph
                end

                case state.inputState do
                    MoveUnitDirection tup do
                        facing := graph.facingNeighbour' state.units[tup[0]].node, tup[1], state.graph
                        u := state.units[tup[0]]
                        unit.drawUnitDirection' u, facing, state.graph
                    end

                    else do end
                end

                defaultFont.drawText' col, "Game", (0., 0.)
            end
            else do <!> end
        end
    end

    love.keypressed = fn _key, scancode, repeat do
        key := input.strToKeyDict[_key]
        case key do
            Escape do
                print' "Quitting game..."
                love.event.quit' 0
            end else do end
        end

        case scene do
            MainMenu menu do
                case key do
                    Return do
                        menu.select()
                    end
                    Space do
                        menu.select()
                    end
                    Up do
                        menu.up()
                    end
                    Down do
                        menu.down()
                    end
                    else do end
                end
            end
            Game state do
                case state.inputState do
                    MoveUnitDirection tup do
                        case key do
                            Space do
                                unitI := tup[0]
                                facing := graph.facingNeighbour' state.units[tup[0]].node, tup[1], state.graph
                                state.units[unitI].node = facing
                            end else do end
                        end
                    end else do end
                end
            end else do <!> end
        end
    end

    love.keyreleased = fn key, scancode do
    end

    love.update = update
    love.draw = draw
end

Maybe :: enum
    Just *,
    Nothing,
end

inputDirection :: fn -> Maybe do // Maybe (float, float)
    res := (0., 0.)
    if input.isKeyDown' input.Key.Up do res += (0., -1.) end
    if input.isKeyDown' input.Key.Down do res += (0., 1.) end
    if input.isKeyDown' input.Key.Left do res += (-1., 0.) end
    if input.isKeyDown' input.Key.Right do res += (1., -0.) end
    if res == (0., 0.,) do
        ret Maybe.Nothing
    end
    ret Maybe.Just (normalize' res)
end

//use gfx
//from gfx use (stableRandomColor as rcol)
//use input
//use sfx
//
//    r := 0.
//
//    aFont :: gfx.aFont()
//    img :: gfx.newImage' "res/sylt.png"
//    ps :: gfx.newParticles' img
//    ps.setParticleLifetime(10., 10.)
//    ps.setEmissionRate(5)
//    ps.setLinearAcceleration((-40., -40.), (40., 40.))
//
//    ss :: gfx.newImplicitSpriteSheet' img, (55, 55)
//
//    s :: sfx.newSound' "res/bloop.wav", false, sfx.SoundType.Static
//
//    updates := []
//    updates -> push' fn delta do
//        if not input.isKeyDown' input.Key.A do
//            r += delta
//        end
//        if input.isKeyDown' input.Key.B do
//            sfx.cloneSound(s).playp' (1.0, 0.8), (1.0, 0.8)
//        end
//    end
//    updates -> push' fn delta do
//        pos :: input.mousePos'
//        ps.setPosition' (cos(r) * 300., sin(r) * 100.) + pos
//        ps.update(delta)
//    end
//
//    love.update = fn delta do
//        updates -> for_each' fn u: fn * -> do u(delta) end
//    end
//
//    love.draw = fn do
//        gfx.drawLine' rcol(1.), (0., 0.), (100., 100.)
//
//        gfx.drawCircle' rcol(2.), (200., 100.), 50.
//        gfx.drawCircleOutline' rcol(3.), (200., 100.), 50.
//
//        gfx.drawRect' rcol(4.), (200., 200.), (50., 50.)
//        gfx.drawRectCentered' rcol(5.), (200., 200.), (50., 50.)
//
//        gfx.drawRectOutline' rcol(5.), (200., 200.), (50., 50.)
//        gfx.drawRectCenteredOutline' rcol(6.), (200., 200.), (50., 50.)
//
//        aFont.drawText' rcol(8.), "Hello world!", (200., 200.)
//        aFont.drawTextT' rcol(9.), "Hello world!", (200., 250.), 1., 2.
//        aFont.drawTextF' rcol(10.), "Hello world!", (200., 250.), gfx.Alignment.Right, 50.
//        aFont.drawTextFT' rcol(11.), "Hello world!", (200., 250.), gfx.Alignment.Right, 50., -1., 2.
//
//        img.draw' (100., 200.), r, (1., 1.)
//        img.drawTinted' rcol(12.), (100., 200.), r + 1., (1., 1.)
//        img.drawCenterd' (100., 200.), r, (1., 1.)
//        img.drawTintedCentered' rcol(12.), (100., 200.), r + 1., (1., 1.)
//
//        ps.draw' gfx.rgb(1., 1., 1.)
//
//        ss.draw' rcol(12.), as_int(rem(r, 4.)), (100., 100.), r, (1., 1.)
//        ss.drawCenterd' rcol(13.), as_int(rem(r, 4.)), (100., 100.), r, (1., 1.)
//    end
