from /love use love
use /gfx

//Camera :: blob {
//
//}

drawGraph :: fn graph: Graph do
    graph.edges -> for_each' fn edge do
        n1 := graph.nodes[edge[0]]
        n2 := graph.nodes[edge[1]]

        c := gfx.rgb' 0., 1., 0.
        gfx.drawLine' c, n1.position, n2.position
    end

    graph.nodes -> for_each' fn node do
        c := gfx.rgb' 1., 0., 0.
        gfx.drawCircle' c, node.position, NODE_SIZE
    end
end

force_function :: fn distance ->
    (NODE_SIZE * 3.50 - distance) * 2.0
end

updateGraph :: fn graph: Graph, delta do
    graph.edges -> for_each' fn edge do
        diff :: graph.nodes[edge[0]].position - graph.nodes[edge[1]].position
        mag  :: force_function' magnitude' diff
        force :: normalize(diff) * (mag, mag)

        graph.nodes[edge[0]].velocity += force
        graph.nodes[edge[1]].velocity -= force
    end

    graph.nodes -> for_each' fn node do
        screen_center :: gfx.screenSizef() * (0.5, 0.5)
        node.velocity += (screen_center - node.position) * (delta, delta)

        force :: 400.
        graph.nodes -> for_each' fn other do
            diff :: node.position - other.position
            mag :: magnitude_squared' diff
            if mag > 5. do
                node.velocity += (force, force) * diff / (mag, mag)
            end
        end

        node.position += node.velocity * (delta, delta)

        damping :: 0.8
        node.velocity *= (damping, damping)
    end
end

Graph :: blob {
    nodes: [Node],
    edges: [(int, int)],
}

Node :: blob {
    position: (float, float),
    velocity: (float, float),
    tile: Tile,
}

new_node :: fn tile ->
    Node {
        position: (as_float(love.math.random(0, 100)), as_float(love.math.random(0, 100))),
        velocity: (0., 0.),
        tile: tile,
    }
end

NODE_SIZE :: 50.

Tile :: enum
    Empty,
    Factory int,
end

neighboursOf :: fn node: int, graph -> [int] do
    neighbours: [int] = []
    graph.edges -> for_each' fn edge do
        if node == edge[0] do
            push' neighbours, edge[1]
        end else if node == edge[1] do
            push' neighbours, edge[0]
        end
    end

    neighbours
end

facingNeighbour :: fn node: int, direction: (float, float), graph -> int do
    nDirection := normalize' direction
    origo := graph.nodes[node].position
    neighbours := neighboursOf' node, graph
    best := -1
    bestScalar := 0.
    neighbours -> for_each' fn neighbour do
        nNeighbour := normalize(graph.nodes[neighbour].position - origo)
        cosPhi := dot' nDirection, nNeighbour

        if cosPhi > bestScalar do
            best = neighbour
            bestScalar = cosPhi
        end
    end

    ret best
end

createGraph :: fn -> Graph do
    Graph {
        nodes: [
            new_node(Tile.Empty),
            new_node(Tile.Empty),
            new_node(Tile.Empty),
            new_node(Tile.Empty),
            new_node(Tile.Empty),
            new_node(Tile.Empty),
            new_node(Tile.Empty),
            new_node(Tile.Empty),
        ],
        edges: [
            (0, 1),
            (1, 2),
            (2, 3),
            (1, 3),
            // (4, 3),
            (4, 6),
            // (4, 5),
            (5, 7),
            (6, 7),
        ],
    }
end
