from /love use love
use /gfx
use guy

from guy use Faction

//Camera :: blob {
//
//}
factionColors :: [
    gfx.rgb(0.384, 0.196, 0.663),
    gfx.rgb(0.800, 0.594, 0.275),
    gfx.rgb(0.467, 0.729, 0.275),
    gfx.rgb(0.820, 0.230, 0.000),
]

factionColor :: fn faction ->
    factionColors[guy.faction_to_int(faction)]
end

shaderColor :: fn node -> int
    case node.tile do
        Base faction ret guy.faction_to_int(faction)
        Factory faction ret guy.faction_to_int(faction)
        Empty ret 4
        EmptyFactory ret 4
        else do <!> end
    end
    ret 4
end

tileColor :: fn tile ->
    case tile do
        Base faction ret factionColor(faction)
        Empty ret gfx.rgb' 0.5, 0.5, 0.5
        EmptyFactory ret gfx.rgb' 0.2, 0.2, 0.2
        Factory faction ret factionColor(faction)
        else do <!> end
    end

    ret gfx.rgb' 0., 0., 0.
end

drawNode :: fn node: Node do
    case node.tile do
        Base faction do
            guy.crest_image(faction).drawCentered' node.position, 0.0, (1., 1.)
        end
        Factory faction do
            c :: tileColor(node.tile)
            gfx.drawCircle' c, node.position, NODE_SIZE
        end
        Empty do
            c :: gfx.rgb' 0.5, 0.5, 0.5
            gfx.drawCircle' c, node.position, NODE_SIZE
        end
        EmptyFactory do
            c :: gfx.rgb' 0.2, 0.2, 0.2
            gfx.drawCircle' c, node.position, NODE_SIZE
        end
        else do <!> end
    end
end

drawGraph :: fn graph: Graph do
    graph.edges -> for_each' fn edge do
        n1 := graph.nodes[edge[0]]
        n2 := graph.nodes[edge[1]]

        c := gfx.rgb' 0., 0., 0.
        gfx.drawLine' c, n1.position, n2.position
    end

    graph.nodes -> for_each' drawNode
end

graphCenter :: fn graph: Graph ->
    centerPosition := (0., 0.)
    graph.nodes -> for_each' fn node do
        centerPosition += node.position
    end

    n :: as_float' len' graph.nodes
    halfWidth :: gfx.screenSizef() * (0.5, 0.5)
    centerPosition = (centerPosition / (n, n)) - halfWidth
    ret (-centerPosition[0] / 2.0, -centerPosition[1] / 2.0)
end

force_function :: fn distance ->
    (NODE_SIZE * 3.50 - distance) * 2.0
end

updateGraph :: fn graph: Graph, delta do
    graph.edges -> for_each' fn edge do
        diff :: graph.nodes[edge[0]].position - graph.nodes[edge[1]].position
        mag  :: force_function' magnitude' diff
        force :: normalize(diff) * (mag, mag)

        graph.nodes[edge[0]].velocity += force
        graph.nodes[edge[1]].velocity -= force
    end

    graph.nodes -> for_each' fn node do
        screen_center :: gfx.screenSizef() * (0.5, 0.5)
        node.velocity += (screen_center - node.position) * (delta, delta)

        force :: 400.
        graph.nodes -> for_each' fn other do
            diff :: node.position - other.position
            mag :: magnitude_squared' diff
            if mag > 5. do
                node.velocity += (force, force) * diff / (mag, mag)
            end
        end

        node.position += node.velocity * (delta, delta)

        damping :: 0.8
        node.velocity *= (damping, damping)
    end
end

Graph :: blob {
    nodes: [Node],
    edges: [(int, int)],
}

Node :: blob {
    position: (float, float),
    velocity: (float, float),
    tile: Tile,
}

new_node :: fn tile, position ->
    width :: love.graphics.getWidth'
    height :: love.graphics.getHeight'

    Node {
        position: position,
        velocity: (0., 0.),
        tile: tile,
    }
end

NODE_SIZE :: 30.

Tile :: enum
    Base Faction,
    Factory Faction,
    Empty,
    EmptyFactory,
end

neighboursOf :: fn node: int, graph -> [int] do
    neighbours: [int] = []
    graph.edges -> for_each' fn edge do
        if node == edge[0] do
            push' neighbours, edge[1]
        end else if node == edge[1] do
            push' neighbours, edge[0]
        end
    end

    neighbours
end

facingNeighbour :: fn node: int, direction: (float, float), graph -> int do
    nDirection := normalize' direction
    origo := graph.nodes[node].position
    neighbours := neighboursOf' node, graph
    best := -1
    bestScalar := -2.
    neighbours -> for_each' fn neighbour do
        nNeighbour := normalize(graph.nodes[neighbour].position - origo)
        cosPhi := dot' nDirection, nNeighbour

        if cosPhi > bestScalar do
            best = neighbour
            bestScalar = cosPhi
        end
    end

    ret best
end

createGraph :: fn -> Graph do
    Graph {
        nodes: [
            new_node(Tile.Empty, (160., 200.)),
            new_node(Tile.Empty, (240., 200.)),
            new_node(Tile.Empty, (320., 200.)),
            new_node(Tile.Empty, (400., 200.)),
            new_node(Tile.Empty, (480., 200.)),
            new_node(Tile.Empty, (560., 200.)),
            new_node(Tile.Empty, (640., 200.)),

            new_node(Tile.Base Faction.Blueberry, (160., 300.)),
            new_node(Tile.Base Faction.Gooseberry, (240., 300.)),
            new_node(Tile.Empty, (320., 300.)),
            new_node(Tile.Empty, (400., 300.)),
            new_node(Tile.Empty, (480., 300.)),
            new_node(Tile.Empty, (560., 300.)),
            new_node(Tile.Base Faction.Cloudberry, (640., 300.)),

            new_node(Tile.Base Faction.Strawberry, (160., 400.)),
            new_node(Tile.Empty, (240., 400.)),
            new_node(Tile.Empty, (320., 400.)),
            new_node(Tile.Empty, (400., 400.)),
            new_node(Tile.Empty, (480., 400.)),
            new_node(Tile.Empty, (560., 400.)),
            new_node(Tile.Empty, (640., 400.)),

            new_node(Tile.Empty, (400., 500.)),
        ],
        edges: [
            (0, 1),
            (1, 2),
            (2, 3),
            (3, 4),
            (4, 5),
            (5, 6),

            (0, 7),
            (1, 9),
            (3, 10),
            (5, 11),
            (6, 13),

            (7, 8),
            (8, 9),
            (9, 10),
            (10, 11),
            (11, 12),
            (12, 13),

            (7, 14),
            (8, 15),
            (10, 17),
            (12, 19),
            (13, 20),

            (14, 15),
            (15, 16),
            (16, 17),
            (17, 18),
            (18, 19),
            (19, 20),

            (16, 21),
            (18, 21),
        ],
    }
end
