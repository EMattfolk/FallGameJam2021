from /love use love
use /gfx

//Camera :: blob {
//
//}

drawGraph :: fn graph: Graph do
    graph.edges -> for_each' fn edge do
        n1 := graph.nodes[edge[0]]
        n2 := graph.nodes[edge[1]]

        c := gfx.rgb' 0., 1., 0.
        gfx.drawLine' c, n1.position, n2.position
    end

    graph.nodes -> for_each' fn node do
        c := gfx.rgb' 1., 0., 0.
        gfx.drawCircle' c, node.position, NODE_SIZE
    end
end

force_function :: fn distance ->
    (NODE_SIZE * 3.50 - distance) * 2.0
end

updateGraph :: fn graph: Graph, delta do
    graph.edges -> for_each' fn edge do
        diff :: graph.nodes[edge[0]].position - graph.nodes[edge[1]].position
        mag  :: force_function' magnitude' diff
        force :: normalize(diff) * (mag, mag)

        graph.nodes[edge[0]].velocity += force
        graph.nodes[edge[1]].velocity -= force
    end

    graph.nodes -> for_each' fn node do
        screen_center :: gfx.screenSizef() * (0.5, 0.5)
        node.velocity += (screen_center - node.position) * (delta, delta)

        force :: 400.
        graph.nodes -> for_each' fn other do
            diff :: node.position - other.position
            mag :: magnitude_squared' diff
            if mag > 5. do
                node.velocity += (force, force) * diff / (mag, mag)
            end
        end

        node.position += node.velocity * (delta, delta)

        damping :: 0.8
        node.velocity *= (damping, damping)
    end
end

Graph :: blob {
    nodes: [Node],
    edges: [(int, int)],
}

Node :: blob {
    position: (float, float),
    velocity: (float, float),
    tile: Tile,
}

new_node :: fn tile ->
    Node {
        position: (as_float(love.math.random(0, 100)), as_float(love.math.random(0, 100))),
        velocity: (0., 0.),
        tile: tile,
    }
end

NODE_SIZE :: 50.

Tile :: enum
    Empty,
    Factory int,
end

createGraph :: fn -> Graph do
    Graph {
        nodes: [
            new_node(Tile.Empty),
            new_node(Tile.Empty),
            new_node(Tile.Empty),
            new_node(Tile.Empty),
            new_node(Tile.Empty),
            new_node(Tile.Empty),
            new_node(Tile.Empty),
            new_node(Tile.Empty),
        ],
        edges: [
            (0, 1),
            (1, 2),
            (2, 3),
            (1, 3),
            // (4, 3),
            (4, 6),
            // (4, 5),
            (5, 7),
            (6, 7),
        ],
    }
end
